#!/bin/bash

LANG=C
LC_ALL=C

set -e
set -x

function checkroot() {
  #
  # Check if we're running as root, and bail out if we're not.
  #
  [[ "${UID}" -ne 0 ]] && {
    echo "[ERROR] Must run as root." >&2
    return 1
  } || :
}

function vm_names(){
  # sort vm names by node_id
  find ${vm_config_dir} -maxdepth 1 -name '*.conf' | while read file; do
    echo "${vm_names} $(basename $file | sed -e 's/\.conf//g'):$(grep ^node_id $file | sed -e 's/^node_id=\([0-9]*\)$/\1/')"
  done | sort -n -t: -k2 | sed -e 's/:[0-9]*$//'
}

function vdc_build_id(){
  cd ${vdc_dir}
  git log -n 1 --pretty=format:"%h"
}

function vdc_release_id(){
  cd ${vdc_dir}
  ./rpmbuild/helpers/gen-release-id.sh
}

function update_vdc(){
  [[ -n ${GIT_COMMIT} ]] && return 0 # running on jenkins
  sync_repo ${vdc_repo_url} ${vdc_checkout_target:-${vdc_branch}} ${vdc_dir}
}

function update_kemumaki(){
  sync_repo ${kemumaki_repo_url} ${kemumaki_branch} ${abs_dirname}
}

function sync_repo(){
  local repo_url=$1
  local target=$2
  local destination=$3
  [[ $# -eq 3 ]] || { echo "[ERROR] Wrong number of arguments $# for 3" >&2; return 1; }
  local revision=${target}
  cd ${destination}
  [[ "${target}" =~ ^[0-9a-f]{40}$ ]] || {
    revision=$(git ls-remote ${repo_url} ${target} | egrep "[0-9a-f]{40} *refs/[^/]*/${target}" | cut -c1-40)
  }
  
  git fetch origin && git fetch --tags origin && git reset --hard ${revision}
  git submodule update --init
}

function prepare(){
  mkdir -p ${image_dir}
  mkdir -p ${tmp_dir}
  mkdir -p ${rpmbuild_tmp_dir}
  mkdir -p ${vdc_dir}

  update_kemumaki
  ( cd ${vdc_dir} && git status || git clone ${vdc_repo_url} )
}

function load_config(){
  [[ ! -f ${config_dir}/kemumaki.conf ]] || . ${config_dir}/kemumaki.conf
}

function load_node_config(){
  [[ ! -f ${vm_config_dir}/${name}.conf ]] || . ${vm_config_dir}/${name}.conf
}

function generate_copy_file(){
  local vm_name=$1 vm_type=$2
  [[ -n "${vm_name}" ]] || { echo "[ERROR] Invalid argument: vm_name:${vm_name}" >&2; return 1; }
  [[ -n "${vm_type}" ]] || { echo "[ERROR] Invalid argument: vm_type:${vm_type}" >&2; return 1; }
  generate_hosts $1
  cat <<EOS > ${vmbuilder_data_dir}/${vm_type}/copy.txt
${tmp_dir}/hosts /etc/hosts
${config_dir}/wakame-vdc.repo /etc/yum.repos.d/wakame-vdc.repo
EOS
}

function generate_hosts(){
  local hostname=$1
  [[ -n "${hostname}" ]] || { echo "[ERROR] Invalid argument: hostname:${hostname}" >&2; return 1; }
  cat <<EOS > ${tmp_dir}/hosts
127.0.0.1 localhost
127.0.0.1 ${hostname}
${amqp_host} amqp-server
${redis_host} redis-server
EOS
}

function notify(){
  [[ "${hipchat_notification}" = true ]] || return 0
  local message=$1
  # add jenkins build url
  [[ -z ${BUILD_URL} ]] || message="${BUILD_URL} ${message}"
  echo -e "${message} " | ${script_dir}/hipchat_room_message -t ${hipchat_token} -r ${hipchat_room_id} -f ${hipchat_from_name}
}

function notify_rpmbuild(){
  local state=${1:-unknown}
  local release_id=$(vdc_release_id)
  notify "rpmbuild: ${state}> ${vdc_branch} of ${vdc_repo_url} (${release_id})"
}

function rpmbuild(){
  #update_vdc # currently don't work with jenkins
  echo "start rpmbuild"
  notify_rpmbuild started
  trap "notify_rpmbuild failed && return 1" ERR
  cd ${script_dir}
  ./setup-ci-env.sh setup_chroot_dir
  ./spot-build.sh ${vdc_dir}
  trap ERR
  notify_rpmbuild done
  echo "done: rpmbuild"
}

function each_vm(){
  local function_names=($*)
  for f in ${function_names[*]}; do
    for name in ${vm_names[*]}; do
      ($f $name)
    done
  done
}

function check_vm(){
  for name in ${vm_names[*]}; do
    [[ "${name}" = $1 ]] && return 0
  done
  echo "[ERROR] '${1}' not found in '${vm_config_dir}'"
  return 1
}

function build_vm(){
  local name=$1
  load_node_config $name
  local vm_dir=${vmbuilder_data_dir}/${vm_type}
  local copy=${vm_dir}/copy.txt
  local script=${vm_dir}/execscript.sh
  # TODO versioning
  local raw_file=${raw_file:-${image_dir}/${name}.raw}

  check_vm ${name} || return 1

  echo "build_vm ${name}"

  generate_copy_file ${name} ${vm_type}

  ${vmbuilder_command} \
    --hostname=${name} \
    --rootsize=${rootsize:-8192} \
    --dns=${dns} \
    --copy=${copy} \
    --execscript=${script} \
    --raw=${raw_file} \
    --ssh-key=${ssh_key} \
    --ssh-user-key=${ssh_user_key} \
    --devel-user=${devel_user} \
    --nictab=${vm_config_dir}/${name}.nic

  # cleanup known_hosts
  [[ -f ~/.ssh/known_hosts ]] && ssh-keygen -R "${ipaddr}"

  return 0
}

function start_vm(){
  local name=$1
  load_node_config $name
  local image_path=${raw_file:-${image_dir}/${name}.raw}

  check_vm ${name} || return 1

  echo "start_vm ${name}"
  
  ${kvm_ctl_command} start \
    --name=${name} \
    --drive="file=${file},media=disk,boot=on,index=0,cache=none" \
    --image-path=${image_path} \
    --vnc_port=$((${vnc_port} + ${node_id})) \
    --monitor_port=$((${monitor_port} + ${node_id})) \
    --serial_port=$((${serial_port} + ${node_id}))

  ${script_dir}/wait_for_ready.sh -h ${redis_host} ${name}
}

function stop_vm(){
  local name=$1
  load_node_config $name
  local vifname=${name}
  check_vm ${name} || return 1

  echo "stop_vm ${name}"

  set +e
  ${kvm_ctl_command} stop --monitor_port=$((${monitor_port} + ${node_id}))
  set -e
}

function run(){
  find -L ${abs_dirname}/tests-enabled -type f -name $1 | sort | while read file; do
    echo running $(basename $(dirname file))
    ${file}
  done
}

checkroot

abs_dirname=$(cd $(dirname ${BASH_SOURCE[0]})/../ && pwd)
script_dir=${abs_dirname}/scripts
# expand environment variable
eval config_dir=${KEMUMAKI_CONFIG_DIR:-${abs_dirname}/config}
vdc_checkout_target=${vdc_checkout_target:-}
vm_config_dir=${config_dir}/vms
vmbuilder_data_dir=${abs_dirname}/builders
image_dir=${abs_dirname}/images
tmp_dir=${abs_dirname}/tmp
rpmbuild_tmp_dir=${tmp_dir}/rpmbuild
vmbuilder_dir=${abs_dirname}/vmbuilder
vmbuilder_command=${vmbuilder_dir}/kvm/rhel/6/vmbuilder.sh
kvm_ctl_command=${vmbuilder_dir}/kvm/rhel/6/misc/kvm-ctl.sh
vnc_port=${vnc_port:-1001}
monitor_port=${monitor_port:-4444}
serial_port=${serial_port:-5555}
brname=${brname:-br0}
netmask=${netmask:-255.255.255.0}
dns=${dns:-8.8.8.8}
vm_names=$(vm_names)

load_config

# kemumaki
kemumaki_repo_url=${kemumaki_repo_url:-git://github.com/axsh/kemumaki.git}
kemumaki_branch=${kemumaki_branch:-master}

# hipchat
hipchat_notification=${HIPCHAT_NOTIFICATION:-${hipchat_notification:-false}}
hipchat_token=${HIPCHAT_TOKEN:-${hipchat_token:-e0d73c2c95311dccfe211f610b08f9}}
hipchat_room_id=${HIPCHAT_ROOM_ID:-${hipchat_room_id:-26976}}
hipchat_from_name=${HIPCHAT_FROM_NAME:-${hipchat_from_name:-kemumaki}}

# vdc
vdc_repo_url=${VDC_REPO_URL:-${vdc_repo_url:-git://github.com/axsh/wakame-vdc.git}}
vdc_branch=${GIT_BRANCH:-${vdc_branch:-master}}
vdc_dir=${WORKSPACE:-${vdc_dir:-${abs_dirname}/wakame-vdc}}

prepare

[[ -n $1 ]] && {
  command=${1}
  shift
}

case ${command} in
  rpmbuild)
    case $1 in
    clean)
      rm -rf ${rpmbuild_tmp_dir} 
      exit 0
      ;;
    *)
      [[ -n $1 ]] && {
        vdc_checkout_target=$1
        shift
      }
      rpmbuild
      ;;
    esac
    ;;
  build_vm)
    if [[ -n "${1}" ]]; then
      build_vm $1
    else
      each_vm build_vm
    fi
    ;;
  start_vm)
    if [[ -n "${1}" ]]; then
      start_vm $1
    else
      each_vm start_vm
    fi
    ;;
  stop_vm)
    if [[ -n "${1}" ]]; then
      stop_vm $1
    else
      each_vm stop_vm
    fi
    ;;
  test)
    run test
    ;;
  report)
    run report
    ;;
  *)
    [[ -n $1 ]] && {
      vdc_checkout_target=$1
      shift
    }
    rpmbuild
    each_vm stop_vm build_vm start_vm
    run test
    run report
    ;;
esac
